# Benchmark
## 1. O Бенчмарке
### Вступление
#### В рамках данного исследования проводится бенчмарк (сравнительное тестирование производительности) нескольких популярных баз данных, реализованных на языке программирования ### Golang. В особом фокусе анализа оказываются DuckDB, PostgreSQL, SQLite, а также библиотеки Gota и Gorm.
### Цели бенчмарка
#### Сравнительная производительность время выполнения запросов
#### Гибкость и удобство использования: Анализ удобства работы с базой данных, возможности поддержки сложных запросов и структуры данных, предоставляемой каждой технологией.
#### Масштабируемость: Исследование способности каждой базы данных масштабироваться при увеличении объема данных и интенсивности запросов.
### Выбор Golang в качестве языка
#### ![image](https://github.com/OneDpsss/Benchmark/assets/108849165/a3b187c1-cb85-4d63-82d4-bc19b2146afc)
#### Использование Golang в этом исследовании обусловлено его выдающейся производительностью, простотой синтаксиса, обширным сообществом разработчиков, а также богатым набором библиотек и фреймворков для работы с базами данных.
## 2.Запросы
### 1)SELECT "VendorID", COUNT(*) FROM "trips" GROUP BY 1;
#### В этом запросе вы выбираете уникальные значения "VendorID" из таблицы "trips" и подсчитываете количество записей для каждого уникального "VendorID". Затем результат группируется по первому столбцу, что в данном случае соответствует "VendorID".
### 2)SELECT "passenger_count", AVG("total_amount") FROM "trips" GROUP BY 1;
#### Этот запрос выбирает уникальные значения "passenger_count" из таблицы "trips" и вычисляет среднее значение "total_amount" для каждого уникального "passenger_count". Результат группируется по первому столбцу ("passenger_count").
### 3)SELECT "passenger_count", EXTRACT(year FROM "tpep_pickup_datetime"), COUNT(*) FROM "trips" GROUP BY 1, 2;
#### Здесь вы выбираете "passenger_count" и извлекаете год из "tpep_pickup_datetime". Затем подсчитываете количество записей для каждой комбинации "passenger_count" и извлеченного года. Результат группируется по двум столбцам.
### 4)SELECT "passenger_count", EXTRACT(year FROM "tpep_pickup_datetime"), ROUND("trip_distance"), COUNT(*) FROM "trips" GROUP BY 1, 2, 3 ORDER BY 2, 4 DESC;
#### Этот запрос аналогичен третьему, но с добавлением столбца "trip_distance", который округляется. Затем результат снова группируется по трем столбцам и упорядочивается сначала по году (второй столбец), а затем по убыванию количества записей (четвертый столбец).
### Каждый из этих запросов предоставляет агрегированную информацию о данных в таблице "trips" в зависимости от выбранных столбцов и заданных условий группировки.

